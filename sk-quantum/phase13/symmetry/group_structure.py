"""
Phase 13.1: Group Structure Analysis of Reversible Gates

This module analyzes the group-theoretic structure of Toffoli/Fredkin gates
and investigates whether they can support spinor representations.

Key Questions:
1. What is the structure of the group generated by Toffoli/Fredkin?
2. Does this group have spinor (complex/projective) representations?
3. What extension is needed to support SO(3) symmetry?
"""

import numpy as np
from typing import List, Tuple, Dict, Set, Optional
from itertools import permutations, product
import sys
import os

# Add phase4 to path for gate definitions
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', '..', 'phase4', 'reversible'))
from gates import ToffoliGate, FredkinGate, CNOTGate


def toffoli_matrix() -> np.ndarray:
    """Get Toffoli gate matrix."""
    return ToffoliGate().to_matrix()


def fredkin_matrix() -> np.ndarray:
    """Get Fredkin gate matrix."""
    return FredkinGate().to_matrix()


class PermutationGroup:
    """Represents a finite permutation group."""
    
    def __init__(self, generators: List[np.ndarray], name: str = "G"):
        """
        Initialize with generator matrices.
        
        Args:
            generators: List of permutation matrices
            name: Name of the group
        """
        self.generators = generators
        self.name = name
        self.n = generators[0].shape[0] if generators else 0
        self._elements: Optional[Set[bytes]] = None
        self._order: Optional[int] = None
        
    def _matrix_to_bytes(self, M: np.ndarray) -> bytes:
        """Convert matrix to hashable bytes."""
        return M.astype(np.int8).tobytes()
    
    def _bytes_to_matrix(self, b: bytes) -> np.ndarray:
        """Convert bytes back to matrix."""
        return np.frombuffer(b, dtype=np.int8).reshape(self.n, self.n).astype(float)
    
    def generate_group(self, max_elements: int = 10000) -> Set[bytes]:
        """Generate all group elements by repeated multiplication."""
        if self._elements is not None:
            return self._elements
            
        elements = {self._matrix_to_bytes(np.eye(self.n))}
        
        # Add generators
        for g in self.generators:
            elements.add(self._matrix_to_bytes(g))
        
        # Closure under multiplication
        changed = True
        while changed and len(elements) < max_elements:
            changed = False
            new_elements = set()
            for e1_bytes in elements:
                e1 = self._bytes_to_matrix(e1_bytes)
                for e2_bytes in elements:
                    e2 = self._bytes_to_matrix(e2_bytes)
                    product = e1 @ e2
                    product_bytes = self._matrix_to_bytes(product.round().astype(int))
                    if product_bytes not in elements:
                        new_elements.add(product_bytes)
                        changed = True
            elements.update(new_elements)
        
        self._elements = elements
        self._order = len(elements)
        return elements
    
    @property
    def order(self) -> int:
        """Return the order (number of elements) of the group."""
        if self._order is None:
            self.generate_group()
        return self._order
    
    def get_elements_as_matrices(self) -> List[np.ndarray]:
        """Return all elements as numpy matrices."""
        elements = self.generate_group()
        return [self._bytes_to_matrix(e) for e in elements]
    
    def compute_character_table(self) -> Dict[str, List[complex]]:
        """
        Compute conjugacy classes and character of natural representation.
        
        Returns:
            Dictionary with conjugacy class info and characters
        """
        elements = self.get_elements_as_matrices()
        
        # Find conjugacy classes
        conjugacy_classes = []
        assigned = [False] * len(elements)
        
        for i, g in enumerate(elements):
            if assigned[i]:
                continue
            
            # Find conjugacy class of g
            conj_class = []
            for j, h in enumerate(elements):
                # Compute h^{-1} g h
                h_inv = h.T  # Orthogonal matrix
                conjugate = h_inv @ g @ h
                
                # Check if conjugate matches any unassigned element
                for k, elem in enumerate(elements):
                    if not assigned[k] and np.allclose(conjugate, elem):
                        if k not in [x[0] for x in conj_class]:
                            conj_class.append((k, elem))
                            assigned[k] = True
                        break
            
            if conj_class:
                conjugacy_classes.append(conj_class)
        
        # Compute character (trace) for each class
        characters = []
        for conj_class in conjugacy_classes:
            _, representative = conj_class[0]
            char = np.trace(representative)
            characters.append((len(conj_class), char))
        
        return {
            'num_classes': len(conjugacy_classes),
            'class_sizes': [len(c) for c in conjugacy_classes],
            'characters': characters
        }


class SpinorAnalysis:
    """
    Analyze whether a finite group can support spinor representations.
    
    A spinor representation requires:
    1. The group to have a double cover (lift to Spin group)
    2. Non-trivial projective representations
    """
    
    def __init__(self, group: PermutationGroup):
        self.group = group
        
    def has_real_eigenvalues_only(self) -> Tuple[bool, List[Tuple[np.ndarray, np.ndarray]]]:
        """
        Check if all group elements have only real eigenvalues.
        
        Permutation matrices have eigenvalues that are roots of unity.
        Elements of order > 2 will have complex eigenvalues (e.g., e^(2πi/3)).
        
        Returns:
            (all_real, list of (matrix, eigenvalues) for elements with non-real eigenvalues)
        """
        elements = self.group.get_elements_as_matrices()
        non_real = []
        
        for M in elements:
            eigenvalues = np.linalg.eigvals(M)
            # Check if any eigenvalue has significant imaginary part
            if any(abs(ev.imag) > 1e-10 for ev in eigenvalues):
                non_real.append((M, eigenvalues))
        
        return len(non_real) == 0, non_real
    
    def has_pm_i_eigenvalues(self) -> Tuple[bool, List[Tuple[np.ndarray, np.ndarray]]]:
        """
        Check if any group element has ±i as eigenvalues.
        
        This is the KEY condition for spinor representations.
        Permutation matrices can have complex eigenvalues (roots of unity),
        but they are NOT ±i (which would require order-4 element with
        eigenvalue exactly on imaginary axis).
        
        Returns:
            (has_pm_i, list of (matrix, eigenvalues) for elements with ±i eigenvalues)
        """
        elements = self.group.get_elements_as_matrices()
        has_pm_i = []
        
        for M in elements:
            eigenvalues = np.linalg.eigvals(M)
            for ev in eigenvalues:
                # Check if eigenvalue is close to +i or -i
                if abs(ev - 1j) < 1e-10 or abs(ev + 1j) < 1e-10:
                    has_pm_i.append((M, eigenvalues))
                    break
        
        return len(has_pm_i) > 0, has_pm_i
    
    def find_j_squared_minus_i(self) -> Tuple[bool, Optional[np.ndarray]]:
        """
        Search for J in the group algebra such that J² = -I.
        
        This is a necessary condition for complex structure.
        
        Note: For permutation matrices (real orthogonal), no such J exists
        in the group itself, but might exist in complex extension.
        """
        elements = self.group.get_elements_as_matrices()
        n = self.group.n
        identity = np.eye(n)
        
        # Check if any element satisfies J² = -I
        for M in elements:
            if np.allclose(M @ M, -identity):
                return True, M
        
        # Check linear combinations (in group algebra over R)
        # J = Σ c_g g, J² = Σ c_g c_h gh = -I
        # This is a quadratic system - check simple cases
        
        # For permutation groups, J² = -I is impossible because:
        # - All eigenvalues of permutation matrices are roots of unity
        # - Eigenvalues of J² are squares of eigenvalues of J
        # - If J² = -I, eigenvalues of J² are all -1
        # - So eigenvalues of J must be ±i
        # - But permutation matrices have real eigenvalues only
        
        return False, None
    
    def compute_schur_multiplier_bound(self) -> Dict:
        """
        Estimate properties related to projective representations.
        
        For finite groups, projective representations are classified by
        the Schur multiplier H²(G, C*).
        
        For symmetric groups S_n:
        - H²(S_n, C*) = Z_2 for n ≥ 4
        - This gives rise to spin representations (double cover)
        """
        order = self.group.order
        
        # Heuristic: check if order is consistent with having double cover
        # For S_n, |S_n| = n!
        # The double cover Spin(n) exists for SO(n)
        
        result = {
            'group_order': order,
            'has_potential_double_cover': order > 1,
            'note': 'Permutation matrices embed in O(n), not SO(n) in general'
        }
        
        return result


class SO3Embedding:
    """
    Analyze conditions for embedding discrete symmetry into SO(3).
    
    Key insight from Wigner: Particles with half-integer spin require
    spinor representations of the rotation group, which are representations
    of SU(2), not SO(3).
    """
    
    def __init__(self, group: PermutationGroup):
        self.group = group
        
    def check_rotation_subgroup(self) -> Dict:
        """
        Check if the group contains elements that could correspond to rotations.
        
        For SO(3), we need:
        - Continuous rotations (not discrete)
        - Or at least, elements whose repeated application approximates rotation
        """
        elements = self.group.get_elements_as_matrices()
        
        # Find element orders
        orders = []
        for M in elements:
            order = 1
            current = M.copy()
            while not np.allclose(current, np.eye(self.group.n)) and order < 1000:
                current = current @ M
                order += 1
            orders.append(order)
        
        max_order = max(orders) if orders else 0
        
        # For approximating SO(3), we need high-order elements
        # Finite subgroups of SO(3) are: cyclic, dihedral, tetrahedral, octahedral, icosahedral
        
        return {
            'max_element_order': max_order,
            'distinct_orders': sorted(set(orders)),
            'can_approximate_continuous': max_order > 10,  # Heuristic
            'note': 'Finite subgroups of SO(3) are limited to polyhedral groups'
        }
    
    def spinor_obstruction(self) -> Dict:
        """
        Identify the obstruction to spinor representations.
        
        The key obstruction: spinors require J² = -I, which means J has eigenvalues ±i.
        Permutation matrices have eigenvalues that are roots of unity (e^(2πik/n)),
        but for J² = -I we need eigenvalues exactly at ±i (i.e., k/n = 1/4 or 3/4),
        which requires n divisible by 4 AND the element having order 4 with
        eigenvalue structure giving ±i.
        """
        spinor_analysis = SpinorAnalysis(self.group)
        has_j2, _ = spinor_analysis.find_j_squared_minus_i()
        has_pm_i, pm_i_elements = spinor_analysis.has_pm_i_eigenvalues()
        
        # Spinor obstruction exists if we can't find J² = -I
        obstruction = not has_j2
        
        return {
            'has_pm_i_eigenvalues': has_pm_i,
            'has_j_squared_minus_i': has_j2,
            'spinor_obstruction': obstruction,
            'explanation': (
                'Spinor representations require J² = -I, which needs eigenvalues ±i. '
                'While permutation matrices can have complex eigenvalues (roots of unity), '
                'finding J² = -I requires a specific structure that permutations lack. '
                f'Has ±i eigenvalues: {has_pm_i}, Has J² = -I: {has_j2}.'
            )
        }


def analyze_toffoli_fredkin_group(n_bits: int = 3) -> Dict:
    """
    Comprehensive analysis of the group generated by Toffoli and Fredkin gates.
    
    Args:
        n_bits: Number of bits (3 for standard gates)
    
    Returns:
        Analysis results
    """
    print(f"=== Analyzing {n_bits}-bit Toffoli/Fredkin Group ===\n")
    
    # Get gate matrices
    T = toffoli_matrix()
    F = fredkin_matrix()
    
    # Create group
    group = PermutationGroup([T, F], name="TF_group")
    
    print(f"Generators: Toffoli, Fredkin ({n_bits}-bit)")
    print(f"State space dimension: {2**n_bits}")
    
    # Generate group
    print("\nGenerating group...")
    group.generate_group()
    print(f"Group order: {group.order}")
    
    # Character analysis
    print("\nComputing character table...")
    char_info = group.compute_character_table()
    print(f"Number of conjugacy classes: {char_info['num_classes']}")
    print(f"Class sizes: {char_info['class_sizes']}")
    
    # Spinor analysis
    print("\n=== Spinor Analysis ===")
    spinor = SpinorAnalysis(group)
    
    all_real, non_real = spinor.has_real_eigenvalues_only()
    print(f"All eigenvalues real: {all_real}")
    if not all_real:
        print(f"Elements with complex eigenvalues: {len(non_real)}")
    
    has_j2, J = spinor.find_j_squared_minus_i()
    print(f"Has J² = -I: {has_j2}")
    
    schur = spinor.compute_schur_multiplier_bound()
    print(f"Schur multiplier analysis: {schur}")
    
    # SO(3) embedding analysis
    print("\n=== SO(3) Embedding Analysis ===")
    so3 = SO3Embedding(group)
    
    rotation = so3.check_rotation_subgroup()
    print(f"Max element order: {rotation['max_element_order']}")
    print(f"Distinct orders: {rotation['distinct_orders']}")
    
    obstruction = so3.spinor_obstruction()
    print(f"\nSpinor obstruction: {obstruction['spinor_obstruction']}")
    print(f"Explanation: {obstruction['explanation']}")
    
    return {
        'group_order': group.order,
        'character_info': char_info,
        'all_eigenvalues_real': all_real,
        'has_j_squared_minus_i': has_j2,
        'spinor_obstruction': obstruction['spinor_obstruction'],
        'rotation_info': rotation
    }


def analyze_symmetric_group(n: int = 4) -> Dict:
    """
    Analyze the symmetric group S_n for comparison.
    
    S_n has a double cover (Schur multiplier Z_2 for n >= 4),
    but the permutation representation itself doesn't capture spinors.
    """
    print(f"\n=== Analyzing Symmetric Group S_{n} ===\n")
    
    # Generate all permutation matrices
    from itertools import permutations
    
    perm_matrices = []
    for perm in permutations(range(n)):
        M = np.zeros((n, n))
        for i, j in enumerate(perm):
            M[i, j] = 1
        perm_matrices.append(M)
    
    group = PermutationGroup(perm_matrices[:2], name=f"S_{n}")  # Use 2 generators
    group._elements = {group._matrix_to_bytes(M) for M in perm_matrices}
    group._order = len(perm_matrices)
    
    import math
    print(f"Group order: {group.order} (should be {n}! = {math.factorial(n)})")
    
    # Spinor analysis
    spinor = SpinorAnalysis(group)
    all_real, _ = spinor.has_real_eigenvalues_only()
    has_j2, _ = spinor.find_j_squared_minus_i()
    
    print(f"All eigenvalues real: {all_real}")
    print(f"Has J² = -I: {has_j2}")
    
    # Note about double cover
    print(f"\nNote: S_{n} has Schur multiplier Z_2 for n >= 4")
    print("This means projective representations exist (double cover)")
    print("But the permutation representation itself is linear, not projective")
    
    # Spinor obstruction
    spinor = SpinorAnalysis(group)
    obstruction = SO3Embedding(group).spinor_obstruction()
    
    return {
        'group_order': group.order,
        'all_eigenvalues_real': all_real,
        'has_j_squared_minus_i': has_j2,
        'spinor_obstruction': obstruction['spinor_obstruction']
    }


def theorem_spinor_obstruction() -> str:
    """
    State the main theorem about spinor obstruction.
    """
    theorem = """
╔══════════════════════════════════════════════════════════════════════════════╗
║  THEOREM (Spinor Obstruction for Permutation Groups)                         ║
╠══════════════════════════════════════════════════════════════════════════════╣
║                                                                              ║
║  Let G ⊂ S_N be a finite permutation group acting on N states.               ║
║  Let ρ: G → GL(N, ℝ) be the permutation representation.                      ║
║                                                                              ║
║  Then:                                                                       ║
║  1. All eigenvalues of ρ(g) are roots of unity (hence real or complex        ║
║     conjugate pairs on the unit circle)                                      ║
║                                                                              ║
║  2. No element J ∈ ρ(G) satisfies J² = -I                                    ║
║                                                                              ║
║  3. Therefore, ρ(G) cannot contain a complex structure                       ║
║                                                                              ║
║  COROLLARY: To obtain spinor representations (required for SO(3) symmetry),  ║
║  one must extend beyond permutation dynamics — this is precisely A1.         ║
║                                                                              ║
╚══════════════════════════════════════════════════════════════════════════════╝
"""
    return theorem


if __name__ == "__main__":
    # Run analysis
    print(theorem_spinor_obstruction())
    
    # Analyze Toffoli/Fredkin group
    tf_results = analyze_toffoli_fredkin_group(n_bits=3)
    
    # Analyze S_4 for comparison
    s4_results = analyze_symmetric_group(n=4)
    
    print("\n" + "="*60)
    print("CONCLUSION")
    print("="*60)
    print("""
The Toffoli/Fredkin group (and more generally, any permutation group)
cannot support spinor representations because:

1. Permutation matrices have only REAL eigenvalues (roots of unity)
2. Spinors require J² = -I, which needs eigenvalues ±i
3. This is a fundamental obstruction that cannot be overcome
   within the permutation framework

To obtain SO(3) symmetry with spinor representations, one MUST
extend the state space beyond classical permutations — this is
precisely the role of Axiom A1 (state space extension).

This provides a GROUP-THEORETIC explanation for why A1 is necessary:
without A1, the symmetry group is limited to finite permutation groups,
which cannot approximate continuous rotation symmetry with spinors.
""")

